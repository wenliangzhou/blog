<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[待了解技术]]></title>
    <url>%2F%E5%BE%85%E4%BA%86%E8%A7%A3%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[通用sdk类产品 JSBridge 埋点sdk 性能分析sdk https://huodong.m.taobao.com/act/layouttestvw.html 质能方程E = mc^2]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端适配方案]]></title>
    <url>%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[适配方案的解析。 lib-flexible 方案：方案原理根据视口设置html font-size使用rem 达到百分比布局的效果,配合熟悉dpr适配文字图片。 优点： 文字能够很好的适配。 直接使用px单位，结合data-dpr 属性编写兼容css，屏幕尺寸够大能够显示更多的文字且各个屏幕文字大小差不多。 1234567891011@mixin font-dpr($font-size)&#123; font-size: $font-size; [data-dpr=&quot;2&quot;] &amp; &#123; font-size: $font-size * 2; &#125; [data-dpr=&quot;3&quot;] &amp; &#123; font-size: $font-size * 3; &#125; &#125;@include font-dpr(16px); 处理1px问题123456789101112131415161718192021222324252627.setTopLine(@c: #C7C7C7) &#123; &amp; &#123; position: relative; &#125; &amp;:before &#123; content: &quot; &quot;; position: absolute; left: 0; top: 0; width: 100%; height: 1px; border-top: 1px solid @c; &#125; [data-dpr=&quot;1&quot;] &amp;:before &#123; transform-origin: 0 0; transform: scaleY(0.5); &#125;&#125;/*照着这个可以再写setBottomLine等相关mixin*/1）它会占用掉before伪类2）没法做圆角3）很难实现多条边框，除非嵌套，或者再利用上after伪类。 缺点雪碧图由于rem转换成px有小数点的存在所以雪碧图的定位不是太准确。 vw适配方案优点简单 使用vw来实现页面的适配，并且通过PostCSS的插件postcss-px-to-viewport2把px转换成vw。这样的好处是，我们在撸码的时候，不需要进行任何的计算，你只需要根据设计图写px单位 为了更好的实现长宽比，特别是针对于img、vedio和iframe元素，通过PostCSS插件postcss-aspect-ratio-mini来实现，在实际使用中，只需要把对应的宽和高写进去即可 为了解决1px的问题，使用PostCSS插件postcss-write-svg,自动生成border-image或者background-image的图片 如果你想系统的学习PostCSS相关的知识，推荐你购买《深入PostCSS Web设计》一书：著作权归作者所有。 缺点 兼容性，不好，但大多数已经支持 另外一点，px转换成vw单位，多少还会存在一定的像素差，毕竟很多时候无法完全整除。 有一些细节之处还是存在一定的缺陷的。比如当容器使用vw单位，margin采用px单位时，很容易造成整体宽度超过100vw，从而影响布局效果。对于类似这样的现象，我们可以采用相关的技术进行规避。比如将margin换成padding，并且配合box-sizing。只不过这不是最佳方案 降级处理 CSS Houdini：通过CSS Houdini针对vw做处理，调用CSS Typed OM Level1 提供的CSSUnitValue API。 CSS Polyfill:通过相应的Polyfill做相应的处理，目前针对于vw单位的Polyfill主要有：vminpoly、Viewport Units Buggyfill、vunits.js和Modernizr。个人推荐采用Viewport Units Buggyfill 具体操作如何在Vue项目中使用vw实现移动端适配 参考至： https://www.w3cplus.com/css/vw-for-layout.html https://www.cnblogs.com/lyzg/p/5117324.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[晨间日记 (第一轮)]]></title>
    <url>%2F%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[主要承诺：每天写一篇日记。 开始时间：2019-12-23 背景让自己有个计划，好去全世界看看。 规则 每天写一篇日记，内容可短，可重复，如果看了有看了文章的心得也会再次总结。 我将在这里跟踪我的进展并推送给GitHub。 如果出现重要的事情，我会跳过这一天不算在100天之中。 阶段 1天 启动日记的编写前端MAP 7天 30天 60天 90天 100天 额外的补充 不要连续两天跳过，并且两周之内跳过一天 日志模板123456789### 第N天#### 昨天的进步#### 思想和情绪#### 今天的计划--- 第1天 2019年12月23日昨天的进步制定今天的日记计划 思想和情绪早晨看了一篇文章。别让自己‘墙了自己’感觉看完自己很有斗志，多看看这样的文章挺好。 文章总结 1.敢想 2.视野的重要性 3.英语对于开阔视野的重要性 4.学习技术不要太偏执，技多不压身，学习一门语言应该有逻辑的思考整个架构模型、设计模式，站在整个技术的上帝视角来学习技术。 5.看完之后觉得自己好年轻。。。（重点.jpg） 今天的计划 详细了解移动端适配原理 自考本科高数段的学习。 Vue源码的视频课程学习。 第2天 2019年12月24日昨天的进步理解CSS基于物理尺寸一样原理，文字适配，图片适配。 思想和情绪对于昨天理解移动端适配还有一点不懂，今天打算直接看源码理解。然后写一篇总结文章。总的来说，没有完成昨天的计划，但在以后的计划规划中要注意合理性。 今天的计划1.继续了解适配原理，写一篇总结文章。2.高数学习 第3天 2019年12月25日昨天的进步理解lib-flexible方案的缺点，和vw适配方案。完成移动端适配的总结 思想和情绪昨天对移动方案的理解还不错，高数暂时搁置。 今天的计划了解vw的文字适配，Vue源码的学习。高数的学习。 第4天 2019年12月26日昨天的进步vw方案文字适配文字是整体放大，没有学习Vue源码，改变计划学习typecript 思想和情绪需要加强效率，合理安排计划，不是很满意。 今天的计划学习typeScript和ES6 第5天 2019年12月27日昨天的进步学习高数曲面方程 思想和情绪高数还是需要花时间的，希望啃下来。 今天的计划学习高数，学习typeScipt 第6天 2019年12月30日昨天的进步周末HI了两天。 余年庆挺好看的。 思想和情绪呀，很难受没坚持下来，特别是作息没坚持下来。 今天的计划学习高数，学习typeScipt 第7天 2020年1月3日昨天的进步学习了一小时数学。曲线旋转方程在Oyz平面的曲线围绕Z旋转因为 曲线f(y,z)=0 又 旋转中的一点p*的z坐标不变且相交于Z轴M，|MP| = \sqrt{x^2+y^2} 又 p在曲线C上,$$f(|MP|=|MP|) $$ 所以 满足f(p*,z) 所以 旋转曲面上的点满足 f(\pm\sqrt{x^2+y^2},z) 思想和情绪新年flag: 养成好的睡眠习惯 再想想 今天的计划学习高数，学习typeScipt 第8天 2020年1月6日昨天的进步《习惯的力量》 习惯三要素：线索、行为、奖赏 线索：地点、心情、心态、上下文，这些会引导自己做出相应行为。 行为：某些习惯需要的动作。 奖赏：分自然奖赏和设计规则奖赏 思想和情绪一定要完成养成早睡早起的习惯，让自己变得从容。 今天的计划1. 跑步。 2. 配置个人博客服务器 3. 地铁上学习typeScript 第9天 2020年1月7日昨天的进步思想和情绪今天的计划]]></content>
      <categories>
        <category>100天挑战</category>
        <category>晨间日记</category>
      </categories>
      <tags>
        <tag>100天挑战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本科自考 (第一轮)]]></title>
    <url>%2F100%E5%A4%A9%E8%87%AA%E8%80%83%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[主要承诺：每天进行自考教材的学习。 开始时间：2019-12-23 背景需要自考一个计算机本科。 规则 每天进行规定自考教材的学习 我将在这里跟踪我的进展并推送给GitHub。 如果出现重要的事情，我会跳过这一天不算在100天之中。 阶段 1天 启动高数的学习 7天 30天 60天 90天 100天 额外的补充 不要连续两天跳过，并且两周之内跳过一天 日志模板123456789### 第N天#### 今天的进步#### 思想和情绪#### 明天的计划--- ``` 第1天今天的进步思想和情绪明天的计划]]></content>
      <categories>
        <category>100天挑战</category>
        <category>自考</category>
      </categories>
      <tags>
        <tag>100天挑战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scss]]></title>
    <url>%2Fscss%2F</url>
    <content type="text"><![CDATA[变量 - variables12345$primary-color: red;div.box&#123; color: $primary-color;&#125; 嵌套 - nesting123456$primary-color: red;div &#123; &amp;.box&#123; color: $primary-color; &#125;&#125; 嵌套式调用父选择器12345div&#123; &amp;:hover&#123; color: red; &#125;&#125; 嵌套属性1234567.nav &#123; font : &#123; size:15px; color:red: &#125;&#125; 混合 - mixins重点 默认值 关键词参数 参数变量 12345678910111213141516171819202122232425262728293031323334353637383940@mixin name (param1,param2...)&#123; ...&#125;// 默认值@mixin border ($width:1px,$color:green)&#123; border :&#123; color:color, width:width &#125;&#125;.box&#123; @include border (12px,red); font-size: 12px;&#125;div&#123; @include border ($color:red); font-size: 12px;&#125;// 参数列表// 可以使用参数变量 … 声明（写在参数的最后方）告诉 Sass 将这些参数视为值列表处理@mixin box-shadow($shadows...) &#123; -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;&#125;.shadows &#123; @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);// 参数变量也可以用在引用混合指令的时候 (@include)，与平时用法一样，将一串值列表中的值逐条作为参数引用：@mixin colors($text, $background, $border) &#123; color: $text; background-color: $background; border-color: $border;&#125;$values: #ff0000, #00ff00, #0000ff;.primary &#123; @include colors($values...);&#125; 继承]]></content>
      <categories>
        <category>前端技术学习记录</category>
        <category>scss</category>
      </categories>
      <tags>
        <tag>前端技术学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[progit]]></title>
    <url>%2Fprogit%2F</url>
    <content type="text"><![CDATA[集中式和分布式版本控制系统的区别 信息配置12345678// 全局信息配置（所有本地仓库提交时，都配置此信息）$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com// 针对该仓库配置 (优先使用配置) $ git config user.name &quot;John Doe&quot;//// 查看信息配置$ git config --list tips /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 —system 选项的git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 —global 选项让 Git读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 获取 Git 仓库在现有目录中初始化仓库1$ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 123$ git add *.c$ git add LICENSE$ git commit -m &apos;initial project version&apos; 克隆现有的仓库1$ git clone https://github.com/libgit2/libgit2 重命名1$ git clone https://github.com/libgit2/libgit2 mylibgit 记录每次更新到仓库相关命令123456789101112// 暂存文件$ git add// 现在的暂存区域已经准备妥当可以提交了$ git commit// 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。$ git diff// 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --cached 命令。//（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。）// 查看状态$ git status// 查看日志$ git log 移除文件12345// 移除README文件// 要从 Git 中移除某个文件，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。$ git rm README// 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在磁盘中。$ git rm --cached README 移动文件(即重命名)1$ git mv file_from file_to 撤消操作重新编辑提交信息123456// 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，// 可以运行带有 --amend 选项的提交命令尝试重新提交：$ git commit -m &apos;initial commit&apos;$ git add forgotten_file$ git commit --amend// 最终你只会有一个提交——第二次提交将代替第一次提交的结果。 取消暂存的文件1234$ git reset HEAD CONTRIBUTING.md// tip:虽然在调用时加上 --hard 选项可以令 git reset 成为一个危险的命令（译注：可能导致工// 作目录中所有当前进度丢失！），但本例中工作目录内的文件并不会被修改。 不加选项地调用// git reset 并不危险 — 它只会修改暂存区域。 撤消对文件的修改123$ git checkout -- CONTRIBUTING.md// tips: 这个命令会丢失当前修改，如果你需要当前进度，但有需要撤销当前修改。此时，使用分支来保存进度会很有用 远程仓库的使用查看远程仓库1git remote -v 添加远程仓库1git remote add &lt;name&gt; &lt;url&gt; 从远程仓库中抓取与拉取git fetch 和git pull 的差别 git fetch 相当于是从远程获取最新到本地，不会自动merge，如下指令： 12345 git fetch orgin master //将远程仓库的master分支下载到本地当前branch中 git log -p master ..origin/master //比较本地的master分支和origin/master分支的差别 git merge origin/master //进行合并 也可以用以下指令：12345git fetch origin master:tmp //从远程仓库master分支获取最新，在本地建立tmp分支git diff tmp //將當前分支和tmp進行對比git merge tmp //合并tmp分支到当前分支 git pull：相当于是从远程获取最新版本并merge到本地 1git pull origin master git pull 相当于从远程获取最新版本并merge到本地 在实际使用中，git fetch更安全一些 推送到远程仓库1git push [remote-name] [branchname]。 查看某个远程仓库1git remote show origin 远程仓库的移除与重命名12345678//如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 //例如，想要将 pb重命名为 paul，可以用 git remote rename 这样做：git remote rename pb paul// 移除远程仓库$ git remote rm paul 打标签列出标签1234567$ git tagv0.1v1.3// 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。// 特定版本 1.8.5 版本git tag -l &apos;v1.8.5*&apos; 创建标签两种标签类型 lightweight(轻量标签) annotated(附注标签) 附注标签1234567891011121314151617$ git tag -a v1.4 -m &quot;my version 1.4&quot;$ git tagv0.1v1.3v1.4// 通过使用 git show 命令可以看到标签信息与对应的提交信息：$ git show v1.4tag v1.4Tagger: Ben Straub &lt;ben@straub.cc&gt;Date: Sat May 3 20:19:12 2014 -0700my version 1.4commit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version number 轻量标签另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 后期打标签1$ git tag -a v1.2 9fceb02 共享标签123$ git push origin v1.5// 推送所有$ git push origin --tags 删除标签1234$ git tag -d v1.4-lw// 应该注意的是上述命令并不会从任何远程仓库中移除这个标签，你必须使用 git push &lt;remote&gt;// :refs/tags/&lt;tagname&gt; 来更新你的远程仓库：$ git push origin :refs/tags/v1.4-lw Git 别名1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status Git 分支指向提交对象的指针 分支的新建与合并给一个项目做贡献将在 featureB 分支上合并的工作推送到服务器上的 featureBee 分支。 1git push -u origin featureB:featureBee 派生的公开项目1234567891011$ git clone (url)$ cd project$ git checkout -b featureA# (work)$ git commit# (work)$ git commit// 创建一份自己的可写的项目派生仓库。$ git remote add myfork (url)$ git push -u myfork featureA// 当工作已经被推送到你的派生后，你需要通知维护者。 这通常被称作一个拉取请求（pull request） 维护项目在特性分支中工作12$ git branch sc/ruby_client master// 现在你已经准备好将别人贡献的工作加入到这个特性分支，并考虑是否将其合并到长期分支中去了。 应用来自邮件的补丁使用 git apply，或者使用 git am。 选择修订版本Git 允许你通过几种方法来指明特定的或者一定范围内的提交。 单个修订版本你可以通过 Git 给出的 SHA-1 值来获取一次提交。 简短的 SHA-112// 如果你想 git show 这个提交$ git show 1c002d 分支引用指明一次提交最直接的方法是有一个指向它的分支引用。 12345678// 假设 topic1 分支指向 ca82a6d ，那么以下的命令是等价的：$ git show ca82a6dff817ec66f44342007202690a93763949$ git show topic1// 如果你想知道某个分支指向哪个特定的 SHA-1$ git rev-parse topic1ca82a6dff817ec66f44342007202690a93763949 引用日志12345// 每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。$ git reflog// 显示5条$ git show HEAD@&#123;5&#125; 祖先引用12// HEAD 的父提交的父提交的父提交的第二个父提交HEAD~3^2 提交区间双点12345678910$ git log master..experimentDC$ git log experiment..masterFE// 查看本地仓库有，远程没有的提交$ git log origin/master..HEAD 多点两个以上的分支才能确定你所需要的修订1234567891011// Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希// 望提交被包含其中的分支。 因此下列3个命令是等价的：$ git log refA..refB$ git log ^refA refB$ git log refB --not refA// 被 refA 或 refB 包含的但是不被 refC 包含的提交$ git log refA refB ^refC$ git log refA refB --not refC 三点123456789101112131415// 如果你想看 master 或者 experiment 中包含的但不是两者共有的提// 交，你可以执行$ git log master...experimentFEDC// --left-right，它会显示每个提交到底处于哪一侧的分支。$ git log --left-right master...experiment&lt; F&lt; E&gt; D&gt; C 重写历史修改最后一次提交1$ git commit --amend 高级合并中断一次合并1$ git merge --abort 忽略空白两个参数选项：-Xignore-all-space 和 -Xignore-space-change第一个选项忽略任意 数量 的已有空白的修改，第二个选项忽略所有空白修改。 1$ git merge -Xignore-space-change branchName 手动文件再合并 git show 命令与一个特别的语法，你可以将冲突文件的这些版本释放出一份拷贝。 12345678910111213141516171819$ git show :1:hello.rb &gt; hello.common.rb$ git show :2:hello.rb &gt; hello.ours.rb$ git show :3:hello.rb &gt; hello.theirs.rb// 使用 ls-files -u 底层命令来得到这些文件的 Git blob 对象的实际 SHA-1值。$ git ls-files -u100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1 hello.rb100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2 hello.rb100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3 hello.rb// 手工修复它们来修复$ dos2unix hello.theirs.rb// git merge-file 命令来重新合并那个文件$ git merge-file -p \ hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb// git clean 命令来清理我们为手动合并而创建但不再有用的额外文件。$ git clean -fRemoving hello.common.rbRemoving hello.ours.rbRemoving hello.theirs.rb 检出冲突上下文关联来解决这些冲突。 12345$ git checkout --conflict=diff3 hello.rb// 通过设置 merge.conflictstyle 选项为 diff3 来做为以后合并冲突的默认选项。$ git config --global merge.conflictstyle diff3 合并日志123456789101112131415161718// 三点语法查出两边都没有的提交$ git log --oneline --left-right HEAD...MERGE_HEAD&lt; f1270f7 update README&lt; 9af9d3b add a README&lt; 694971d update phrase to hola world&gt; e3eb223 add more tests&gt; 7cff591 add testing script&gt; c3ffff1 changed text to hello mundo// 查出冲突的提交$ git log --oneline --left-right --merge&lt; 694971d update phrase to hola world&gt; c3ffff1 changed text to hello mundo// 如果你运行命令时用 -p 选项代替，你会得到所有冲突文件的区别。 // 快速获得你需要帮助理解为什么发生冲突的// 上下文，以及如何聪明地解决它，这会 非常 有用。 组合式差异格式123$ git diff$ git log --cc -p -1 撤消合并修复引用12// 如果这个不想要的合并提交只存在于你的本地仓库中，git reset --hard HEAD~ 还原提交12345$ git revert -m 1 HEAD[master b1d8379] Revert &quot;Merge branch &apos;topic&apos;&quot;$ git revert ^M[master 09f0126] Revert &quot;Revert &quot;Merge branch &apos;topic&apos;&quot;&quot;$ git merge topic 其他类型的合并我们的或他们的偏好传递给 merge 命令一个-Xours 或 -Xtheirs 参数。 12345678// 冲突时可以应用其中一边$ git merge -Xours mundo// 只应用其中一边，简单的假合并$ git merge -s ours mundo// 当再次合并时从本质上欺骗 Git 认为那个分支已经合并过经常是很有用的。 子树合并子模块开始使用子模块1$ git submodule add https://github.com/chaconinc/DbConnector 克隆含有子模块的项目1234567$ git clone https://github.com/chaconinc/MainProject// 此时子目录还是空的$ git submodule init$ git submodule update 在包含子模块的项目上工作拉取上游修改1234// 如果想要在子模块中查看新工作，可以进入到目录中运行 git fetch 与 git merge$ git fetch$ git merge origin/master 在子模块上工作12]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>progit</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POST提交数据之---Content-Type的理解]]></title>
    <url>%2FPOST%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E4%B9%8B-Content-Type%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Content-Type的理解Content-Type是指http/https发送信息至服务器时的内容编码类型，contentType用于表明发送数据流的类型，服务器根据编码类型使用特定的解析方式，获取数据流中的数据。在网络请求中，常用的Content-Type有如下：text/html, text/plain, text/css, text/javascript, image/jpeg, image/png, image/gif,application/x-www-form-urlencoded, multipart/form-data, application/json, application/xml 等。其中：text/html, text/plain, text/css, text/javascript, image/jpeg, image/png, image/gif, 都是常见的页面资源类型。application/x-www-form-urlencoded, multipart/form-data, application/json, application/xml 这四个是ajax的请求，表单提交或上传文件的常用的资源类型。form表单中可以定义enctype属性，该属性的含义是在发送到服务器之前应该如何对表单数据进行编码。默认的情况下，表单数据会编码为“application/x-www-form-unlencoded”.enctype常用的属性值如下：application/x-www-form-unlencoded： 在发送前编码所有字符(默认情况下)；multipart/form-data, 不对字符编码。在使用文件上传时候，使用该值。 错误设置Content-Type可能会导致的问题application/json 可能会导致 使用JSON JavaScriptSerializer 进行序列化或反序列化时出错。字符串的长度超过了为 maxJsonLength属性,后台解析错误， 还可能出现跨域问题 解决办法：设置为application/x-www-form-urlencoded则OK，]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RSA不对称加密原理]]></title>
    <url>%2FRSA%E4%B8%8D%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[RSA加密简介RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。 RSA加密、签名区别加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举2个例子说明。 第一个场景：战场上，B要给A传递一条消息，内容为某一指令。 RSA的加密过程如下： A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。 A传递自己的公钥给B，B用A的公钥对消息进行加密。 A接收到B加密的消息，利用A自己的私钥对消息进行解密。 在这个过程中，只有2次传递过程，第一次是A传递公钥给B，第二次是B传递加密消息给A，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行解密，防止了消息内容的泄露。 第二个场景：A收到B发的消息后，需要进行回复“收到”。 RSA签名的过程如下： A生成一对密钥（公钥和私钥），私钥不公开，A自己保留。公钥为公开的，任何人可以获取。 A用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给B。 B收到消息后，在获取A的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是A回复的。 在这个过程中，只有2次传递过程，第一次是A传递加签的消息和消息本身给B，第二次是B获取A的公钥，即使都被敌方截获，也没有危险性，因为只有A的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给B，防止了消息内容的篡改。 但是，综合两个场景你会发现，第一个场景虽然被截获的消息没有泄露，但是可以利用截获的公钥，将假指令进行加密，然后传递给A。第二个场景虽然截获的消息不能被篡改，但是消息的内容可以利用公钥验签来获得，并不能防止泄露。所以在实际应用中，要根据情况使用，也可以同时使用加密和签名，比如A和B都有一套自己的公钥和私钥，当A要给B发送消息时，先用B的公钥对消息加密，再对加密的消息使用A的私钥加签名，达到既不泄露也不被篡改，更能保证消息的安全性。 总结：公钥加密、私钥解密、私钥签名、公钥验签。PS:RSA加密对明文的长度有所限制，规定需加密的明文最大长度=密钥长度-11（单位是字节，即byte），所以在加密和解密的过程中需要分块进行。而密钥默认是1024位，即1024位/8位-11=128-11=117字节。所以默认加密前的明文最大长度117字节，解密密文最大长度为128字。那么为啥两者相差11字节呢？是因为RSA加密使用到了填充模式（padding），即内容不足117字节时会自动填满，用到填充模式自然会占用一定的字节，而且这部分字节也是参与加密的。 密钥长度的设置就是上面例子的第32行。可自行调整，当然非对称加密随着密钥变长，安全性上升的同时性能也会有所下降。 转载自技术宅de小坑]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"></content>
      <categories>
        <category>书籍笔记</category>
        <category>JavaScript高级程序设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高级程序设计笔记]]></title>
    <url>%2FJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[DOM概念文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API，Application Programming Interface）。通过 DOM 创建的这个表示文档的树形图，开发人员获得了控制页面内容和结构的主动权。借助DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。 小结理解 DOM 的关键，就是理解 DOM 对性能的影响。DOM 操作往往是 JavaScript 程序中开销最大的 2 部分，而因访问 NodeList 导致的问题为最多。NodeList 对象都是“动态的”，这就意味着每次访问NodeList 对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少 DOM 操作。 内存和性能由于事件处理程序可以为现代 Web 应用程序提供交互能力，因此许多开发人员会不分青红皂白地向页面中添加大量的处理程序。在创建 GUI 的语言（如 C#）中，为 GUI 中的每个按钮添加一个 onclick事件处理程序是司空见惯的事，而且这样做也不会导致什么问题。可是在 JavaScript 中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。事实上，从如何利用好事件处理程序的角度出发，还是有一些方法能够提升性能的。 事件委托可以解决性能，和设置未来添加的元素的事件 移除事件处理程序在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的 DOM 操作，例如使用 removeChild()和 replaceChild()方法，但更多地是发生在使用 innerHTML 替换页面中某一部分的时候。如果带有事件处理程序的元素被 innerHTML 删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。来看下面的例子。 函数柯里化1234567891011121314function curry(fn)&#123; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; var innerArgs = Array.prototype.slice.call(arguments); var finalArgs = args.concat(innerArgs); return fn.apply(null, finalArgs); &#125;; &#125;function add(num1, num2)&#123; return num1 + num2; &#125; var curriedAdd = curry(add, 5); alert(curriedAdd(3)); //8 当使用 bind()时，它会返回绑定到给定环境的函数，并且可能它其中某些函数参数已经被设好。当你想除了 event 对象再额外给事件处理程序传递参数时，这非常有用，例如： 123456789ECMAScript 5 的 bind()方法也实现函数柯里化，只要在 this 的值之后再传入另一个参数即可。var handler = &#123; message: "Event handled", handleClick: function(name, event)&#123; alert(this.message + ":" + name + ":" + event.type); &#125; &#125;; var btn = document.getElementById("my-btn"); EventUtil.addHandler(btn, "click", handler.handleClick.bind(handler, "my-btn")); JavaScript 中的柯里化函数和绑定函数提供了强大的动态函数创建功能。使用 bind()还是 curry()要根据是否需要 object 对象响应来决定。它们都能用于创建复杂的算法和功能，当然两者都不应滥用，因为每个函数都会带来额外的开销。 自定义事件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function EventTarget() &#123; this.handlers = &#123;&#125;; &#125;EventTarget.prototype = &#123; constructor: EventTarget, addHandler: function (type, handler) &#123; if (typeof this.handlers[type] == "undefined") &#123; this.handlers[type] = []; &#125; this.handlers[type].push(handler); &#125;, fire: function (event) &#123; if (!event.target) &#123; event.target = this; &#125; if (this.handlers[event.type] instanceof Array) &#123; var handlers = this.handlers[event.type]; for (var i = 0, len = handlers.length; i &lt; len; i++) &#123; handlers[i](event); &#125; &#125; &#125;, removeHandler: function (type, handler) &#123; if (this.handlers[type] instanceof Array) &#123; var handlers = this.handlers[type]; for (var i = 0, len = handlers.length; i &lt; len; i++) &#123; if (handlers[i] === handler) &#123; break; &#125; &#125; handlers.splice(i, 1); &#125; &#125;&#125;;function handleMessage(event)&#123; alert("Message received: " + event.message); &#125; //创建一个新对象var target = new EventTarget(); //添加一个事件处理程序target.addHandler("message", handleMessage); //触发事件target.fire(&#123; type: "message", message: "Hello world!"&#125;); //删除事件处理程序target.removeHandler("message", handleMessage); //再次，应没有处理程序target.fire(&#123; type: "message", message: "Hello world!"&#125;);]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>JavaScript高级程序设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C#-learn]]></title>
    <url>%2Fc-learn%2F</url>
    <content type="text"><![CDATA[主要承诺：C# 学习笔记的记录 开始时间：2019-7-15 背景目前工作的后端技术栈是.net，所以有必要学习和对后续学习其他后端语言打好一点基础。 规则 尽量快速掌握C#，并实践 复习该笔记。 阶段 1天 7天 30天 60天 90天 100天 额外的补充 难点等深度扩展，会另写一篇文章进行记录。 日志模板123456789### 第N天#### 学习节点标题 -内容：笔记#### 思想和情绪#### 明天的计划--- 第1天 2019年8月7日C#简介C# 是专为公共语言基础结构（CLI）设计的。CLI 由可执行代码和运行时环境组成，允许在不同的计算机平台和体系结构上使用各种高级语言。 .Net 框架（.Net Framework）.Net 框架应用程序是多平台的应用程序。框架的设计方式使它适用于下列各种语言：C#、C++、Visual Basic、Jscript、COBOL 等等。所有这些语言可以访问框架，彼此之间也可以互相交互。 .Net 框架由一个巨大的代码库组成，用于 C# 等客户端语言。下面列出一些 .Net 框架的组件： 公共语言运行库（Common Language Runtime - CLR） .Net 框架类库（.Net Framework Class Library） 公共语言规范（Common Language Specification） 通用类型系统（Common Type System） 元数据（Metadata）和组件（Assemblies） Windows 窗体（Windows Forms） ASP.Net 和 ASP.Net AJAX ADO.Net Windows 工作流基础（Windows Workflow Foundation - WF） Windows 显示基础（Windows Presentation Foundation） Windows 通信基础（Windows Communication Foundation - WCF） LINQ 思想和情绪明天的计划 第2天 2019年8月8日C# 数据类型在 C# 中，变量分为以下几种类型： 值类型（Value types） 引用类型（Reference types） 指针类型（Pointer types） 动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。 思想和情绪明天的计划]]></content>
      <categories>
        <category>前端技术学习记录</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>前端技术学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[中介者模式应用程序，无论其大小，都是由一些单个的对象所组成。所有这些对象需要一种方式来实现相互通信，而这种通信方式在一定程度上不降低可维护性，也不损害那种安全的改变部分应用程序而不会破坏其余部分的能力。随着应用程序的增长，将添加越来越多的对象。然后再代码重构期间，对象将被删除或者重新整理。当对象互相知道太多信息并且直接通信（调用对方的方法并改变属性）时，这将会导致产生不良的紧耦合（tight coupling）问题。当对象间紧密耦合时，很难在改变单个对象的同时不影响其他多个对象。因而，即使对应用程序进行最简单的修改也变得不再容易，而且几乎无法估计修改可能话费的时间。 中介者模式缓解了该问题并促进形成松耦合(loose coupling),而且还有助于提高可维护性。这种模式中，独立的对象之间并不直接通信，而是通过mediator将会把该变化传到任意其他应该只知道此变化的colleague对象。 中介者示例下面让我们探讨使用中介模式的例子。该应用程序是一个游戏程序，其中两名玩家分别给予半分钟的时间以竞争决胜出谁会比另一个按更多次数的按钮。在比赛中玩家1按2，而玩家2按0。计分板依据当前得分进行更新。 本例中参与的对象如下所示： 玩家1 玩家2 计分板 中介者 中介者知道所有其他对象的信息。它与输入设备(键盘)进行通信并处理键盘按键事件，并且还要决定是哪个玩家前进了一个回合，随后还将该消息通知给玩家。玩家玩游戏的同时，还要通知中介者他所做的事情。中介者将更新后的分数传达给计分板，计分板随后更新显示的分值。 除了中介者以外，没有对象知道任何其他对象。这种模式使得更新游戏变得非常方便，比如，通过该中介者可以很容易添加一个新的玩家或者另一个显示剩余时间的显示窗口。 player对象是由Player()构造函数所创建的，具有points和name属性。原型中的play()方法每次以1递增分数，然后通知中介者。 12345678function Player (name)&#123; this.points = 0; this.name = name;&#125;Player.prototype.play = function () &#123; this.points +=1; mediator.played();&#125; scoreboard对象中有一个update()方法,在轮到每个玩家游戏结束之后mediator对象将调用该方法。scoreboard并不知道任何玩家的接口并且也没有保存分值，它仅根据mediator给定的值显示当前分数： 12345678910111213141516var scoreboard = &#123; // 待更新的HTML元素 element: document.getElementById('results), // 更新得分显示 update:function(score)&#123; var i,msg = ''; for (i in score)&#123; if(score.hasOwnProperty(i)) &#123; msg += '&lt;p&gt;&lt;strong&gt;'+i+'&lt;\/strong&gt;'; msg += score[i]; msg += '&lt;\/p&gt;'; &#125; &#125; this.element.innerHMTL = msg; &#125;;&#125; 现在，让我们来查看一下mediator对象。它首先初始化游戏，在它的setup()方法中创建player对象，然后将这些player对象记录到自己的players属性中。其中,played()方法将在每轮游戏后由player所调用。该方法更新score哈希表并将其发送到scoreboard中以用于显示分值。最后一个方法为keypress(),它用于处理键盘事件，确定那个玩家前进了一个回合并通知该玩家： 12345678910111213141516171819202122232425262728293031var mediator = &#123; // 所有的玩家(player对象) players:&#123;&#125;, // 初始化 setup:function()&#123; var players = this.players; players.home = new Player('Home'); players.guest = new Player('Guest'); &#125;, // 如果有人玩,则更新得分值 played:function ()&#123; var players = this.players, score = &#123; Home: players.home.points, Guest:players.guest.points &#125;; scoreboard.update(score); &#125;, // 处理用户交互 keypress:function (e)&#123; e = e || window.event; //IE浏览器 if(e.which === 49)&#123; // 按键1 mediator.players.home.play(); return; &#125; if(e.which === 48)&#123; // 按键2 mediator.players.guest.play(); return; &#125; &#125;&#125; 而最后的事情就是要建立以及拆除该游戏：123456789// 运行!mediator.setup();window.onkeypress = mediator.keypress;// 游戏在30秒内结束setTimeout(function()&#123; window.onkeypress = null; alert('Game over!');&#125;,30000);]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式 缓存代理]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式外观(facade)模式是一种简单的模式，它为对象提供了一个可供选择的接口。这是一种非常好的设计模式实践，可保持方法的简洁性并且不会使他们处理过多的工作。如果原来有许多接受多个参数的uber方法，相比而言，按照本方法实现，最终将会创建更多数量的方法。有时候，两个或者更多的方法可能普遍的被遗弃调用。在这种情况下，创建另一个方法以包装重复的方法调用时非常有意义的。 例如：123456789101112131415161718192021var myevent = &#123; stop:function(e)&#123; e.preventDefault(); e.stopPropagation(); &#125; //...&#125;// 外观模式也非常适合于浏览器脚本处理，据此可将浏览器之间的差异隐藏在外观之后。var myevent = &#123; stop:function (e)&#123; // 其他 if(typeof e.preventDefault === "function")&#123; e.preventDefault(); &#125; // IE浏览器 if()&#123; //.... &#125; &#125;&#125; 利于重构外观模式对于重新设计和重构的工作也很有帮助。当需要替换一个具有不同实现的对象时，不得不花一段时间对它重新进行修改（这是一个复杂的对象），而且同时还需要使用该对象的新代码。通过使用外观模式，可以首先考虑对象的API，然后继续在原有对象的前面创建一个外观。这样，当您着手完全取代原有对象的时候，仅需修改更少的客户端代码，这是由于任何最新的客户端代码都已经使用了这个新API。]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在装饰者模式中，可以在运行时动态添加功能到对象中。当处理静态类时，这可能是一个挑战。在Javasctipt中，由于对象是可变的，因此，添加功能到对象中的过程本身并不是问题。 装饰者模式的一个比较方便的特征在于其预期行为的可定制和可配置特性。可以从仅具有一些基本功能的普通对象开始，然后从可用装饰资源池中选择需要用于增强普通对象的那些功能，并且按照顺序进行装饰，尤其是当装饰顺序很重要的时候。 期望形式: 12345var sale = new Sale(100); //该价格为100美元sale = sale.decorate('fedtax'); //增加联邦税sale = sale.decorate('quebec'); //增加省级税sale = sale.decorate('money'); //格式化为美元货币形式sale.getPrice(); 实现方式: 123456789101112131415161718192021222324252627282930313233343536373839function Sale(price=100)&#123; this.price = 100;&#125;Sale.prototype.getPrice = function ()&#123; return this.price;&#125;;// 装饰着对象都将以构造函数的属性这种方式来实现：Sale.decorators = &#123;&#125;;Sale.decorators.fedtax = &#123; getPrice:function()&#123; var price = this.uber.getPrice(); price += price * 5/100; return price; &#125;&#125;;Sale.decorators.quebec = &#123; getPrice:function ()&#123; var price = this.uber.getPrice(); price += price*7.5/100; return price; &#125;&#125;...// 最后decorate()方法，它可以将所有的块拼接在一起。Sale.prototype.decorate = function (decorator)&#123; var F = function () &#123;&#125;, overrides = this.constructor.decorators[decorator], i,newobj; F.prototype = this; newobj = new F(); newobj.uber = F.prototype; for(i in overrides)&#123; if(overrides.hasOwnProperty(i))&#123; newobj[i] = overrides[i]; &#125; &#125; return newobj;&#125; 使用列表实现123456789101112131415161718192021222324252627282930313233343536373839var sale = new Sale(100);sale.decorate('fedtax');sale.decorate('quebec');sale.decorate('money');sale.getPrice(); //$112.88function Sale(price = 100)&#123; this.price = price; this.decorators_list = [];&#125;Sale.decorators = &#123;&#125;;Sale.decorators.fedtax = &#123; getPrice:function(price)&#123; return price + price *5/100; &#125;&#125;Sale.decorators.quebec = &#123; getPrice:function(price)&#123; return price + price *7.5/100; &#125;&#125;Sale.decorators.money = &#123; getPrice:function(price)&#123; return '$' + price.toFixed(2); &#125;&#125;Sale.prototype.decorate = function(decorator)&#123; this.decorators_list.push(decorator);&#125;Sale.prototype.getPrice = function()&#123; var price = this.price,i,max = this.decorators_list.length,name; for(i==0;i&lt;max;i+=1)&#123; name = this.decorators_list[i]; price = Sale.decorators[name].getPrice(price); &#125; return price;&#125;]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[观察者模式(发布/订阅)]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者(observer)模式广泛应用于客户端Javacript编程中。所有浏览器事件（鼠标悬停，按键等事件）是该模式的例子。它的另一个名字也称为自定义事件（custom evensts）,与那些浏览器事件相比，自定义事件表示是由您编程实现的事件。此外，该模式的另外一个别名是订阅/发布(subscriber/publisher)模式。 设计这种模式背后的主要动机是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称之为观察者，而被观察的对象被称为发布者或者主题。发生一个重要的事件时，发布者将会通知(调用)所有订阅者并且可能经常以事件对象的形式传递消息。 代码示例：杂志订阅subscribers 一个数组subscribe() 将订阅者添加到subscribers数组。unsubscribe() 从订阅者数组中删除订阅者。publish() 循环遍历subscribers中的每个元素，并且调用他们注册时所提供的方法。 所有这三种方法都需要一个type参数，因为发布者可能触发多个事件，而其中某些用户仅订阅了一种事件。由于这些成员对于任何发布者对象都是通用的，将它们作为一个独立对象的一个部分来实现是很有意义的。那样我们可以将其赋值到任何对象中，并且将任意给定的对象变成一个发布者。 下面是该通用发布者功能的一个实现示例，它定义了前面列举的所有需要的成员，还加上了一个帮助方法visitSubscribers()；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var publisher = &#123; subscribers:&#123; any:[] //事件类型：订阅者 &#125;, subscribe:function(fn,type='any')&#123; if(typeof this.subscribers[type] === undefined)&#123; this.subscribers[type] = []; &#125; this.subscribers[type].push(fn); &#125;, unsubscribe:function(fn,type)&#123; this.visitSubscribers('unsubscribe',fn,type); &#125;, publish:function(publication,type)&#123; this.visitSubscribers('publish',publication,type); &#125;, visitSubscribers:function(action,arg,type='any')&#123; var subscribers = this.subscribers[type],i,max = subscribers.length; for(i = 0,i&lt;max;i+=1)&#123; if(action==='publish')&#123; subscribers[i](arg); &#125;else&#123; if(subscribers[i]===arg)&#123; subscribers.splice(i,1); &#125; &#125; &#125; &#125;&#125;function makePublisher(o)&#123; var i; for(i in publisher)&#123; if(publisher.hasOwnProperty(i)&amp;&amp; typeof publisher[i]=== 'function')&#123; o[i] = publisher[i]; &#125; &#125; o.subscribers = &#123;any:[]&#125;;&#125;// 现在，让我们来实现paper对象。它所能做的就是发布日报和月刊：var paper = &#123; daily:function()&#123; this.publish('big news today'); &#125;, monthly:function()&#123; this.publish('interesting analysis','monthly'); &#125;&#125;// 将paper构造成一个发布者;makerPublisher(paper);var joe = &#123; drinkCoffee:function(paper)&#123; console.log('Just read'+paper); &#125;, sundayPreNap:function(monthly)&#123; console.log('About to fall asleep reading this'+monthly); &#125;&#125;;paper.subscribe(joe.drinkCoffee);paper.subscribe(joe.sundayPreNap,'monthly');paper.daily();paper.daily();paper.monthly();]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在迭代器模式中，通常有一个包含某种数据集合的对象。该数据可能储存在一个复杂的数据结构内部，而要提供一种简单的方法能够访问数据结构中每个元素。对象的消费者并不知道如何组织数据，所有需要做的就是取出单个数据进行工作。 在迭代器模式中，对象需要提供一个next()方法,依次调用next()必须返回下一个连续的元素。在特定的数据结构中，‘下一个’所代表的意义是由您来决定的。 代码示例： 12345678910111213141516171819202122232425var agg = (function()&#123; var index = 0; var data = [1,2,3,4,5]; var len = data.length; return &#123; next:function()&#123; var element; if(!this.hasNext())&#123; return null; &#125; element = data[index]; index = index + 2; return element; &#125;, hasNext:function()&#123; return index &lt; len; &#125;, rewind:function()&#123; //恢复指针 index = 0; &#125;, current:function()&#123; //返回当前元素 return data[index]; &#125; &#125;;&#125;());]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[node-learn]]></title>
    <url>%2Fnode-learn%2F</url>
    <content type="text"><![CDATA[主要承诺：node 学习笔记的记录 开始时间：2019-7-15 背景在开启多方便学习记录的同时，开启技术学习记录。 规则 尽量快速掌握node，并实践 复习该笔记。 阶段 1天 7天 30天 60天 90天 100天 额外的补充 难点等深度扩展，会另写一篇文章进行记录。 日志模板123456789### 第N天#### 今天的进步#### 思想和情绪#### 明天的计划--- 第1天 2019年7月15日今天的进步思想和情绪明天的计划]]></content>
      <categories>
        <category>前端技术学习记录</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端技术学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化-SSR]]></title>
    <url>%2FSSR%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端技术学习记录</category>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>前端技术学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-组件设计]]></title>
    <url>%2F%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[封装注意 .sync 修饰符，指令的灵活运用。]]></content>
      <categories>
        <category>前端技术学习记录</category>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>前端技术学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finance]]></title>
    <url>%2Ffinance%2F</url>
    <content type="text"><![CDATA[主要承诺：进行金融知识框架的搭建 开始时间：2019-7-15 背景开启金融框架学习的记录，以便更好的鞭策自己，由于英语第二轮在开启中，这门课有时间会尽量进行记录，和复习。 规则 如果有学习新的课程，会在此记录笔记。 复习该笔记。 阶段 1天 7天 30天 60天 90天 100天 额外的补充 日志模板 123456789### 第N天#### 今天的进步#### 思想和情绪#### 明天的计划--- 第1天 2019年7月15日今天的进步思想和情绪明天的计划]]></content>
      <categories>
        <category>财务自由</category>
        <category>金融框架的搭建</category>
      </categories>
      <tags>
        <tag>财务自由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100天英语挑战 (第二轮)]]></title>
    <url>%2Flearn-english-1%2F</url>
    <content type="text"><![CDATA[主要承诺：每天进行英语学习 开始时间：2019-7-15 背景第一轮英语学习没有日常更新，项目比较忙，但我觉得这不是理由，希望这轮能够坚持下去。因为上一轮已经背了1400个基础单词，如果能够坚持下去应该会有很好的结果，而且在下次开启学习记录前有一个很好的开头。so,up up up. 规则 每天进行英语学习 我将在这里跟踪我的进展并推送给GitHub。 如果出现重要的事情，我会跳过这一天不算在100天之中。 阶段 1天 7天 30天 60天 90天 100天 额外的补充 不要连续两天跳过，并且两周之内跳过一天 日志模板123456789### 第N天#### 今天的进步#### 思想和情绪#### 明天的计划--- 第1天 2019年7月15日今天的进步思想和情绪明天的计划]]></content>
      <categories>
        <category>100天挑战</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>100天挑战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html调用摄像头录制视频拍照]]></title>
    <url>%2Fhtml%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91%E6%8B%8D%E7%85%A7%2F</url>
    <content type="text"><![CDATA[需求： html5兼容调用摄像头录制，及拍照。 兼容情况： QQ，微信，自家APP内嵌的html5页面。 痛点： 安卓录制视频太大，和摄像头的像素有关系，图片大到没有关系可以canvas压缩。但视频没有太好的办法。除了第一步用getusermediaAPI获取视频流，在用mediarecorderAPI进行处理数据。可以控制视频大小。IOS录 制的视频系统貌似自动做了压缩，视频不是很大。 所以采用原生 input file和getusermediaAPI两种方式结合进行摄像头调用。 下面就是vue组件代码代码： 组件思路基本如下: camera组件需注意:各种浏览器点击是否直接弹出相机，还是有选择文件，相册，属性的配置是不同的。所以做了如下代码的兼容。但QQ嵌入浏览器只能有选择文件的选项，不能配置直接弹出相机。至于APP,自己APP直接file文件不能弹出相机,只有选择文件，后面APP更新了，，貌似是APP禁用了file弹出相机应该有某些权限设置的原因。 mediarecorder组件在安卓浏览器情况下用调用就可以了。不同端调用组件的情况： IOS 调用camera组件 安卓浏览器情况下 调用mediarecorder组件 APP内嵌h5 调用调用camera组件 (ps：可能权限问题不能调用相机，但是ios 自己APP可以调用相机)那怎么判断是在APP呢，IOS还是安卓直接UA判断就可以了。可以通过设置url参数只要有这个参数，一定是在APP下访问的h5页面。当然可能不适用所有场景。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242// 相机拍照录制组件var camera = &#123; template: '&lt;label class="hidd"&gt;' + '&lt;input type="file" :class="_class" :name="name" :accept="_accept" :capture = "qqOrWx" &gt;' + '&lt;/label&gt;', props: [ 'accept', 'capture', 'name', '_class', 'direct' ], computed: &#123; '_accept': function () &#123; return this.accept || 'image/*'; &#125;, 'qqOrWx': function () &#123; if (this.direct) &#123; return this.capture; &#125; this.isWQ(); switch (this.isqq) &#123; case 'qq': return this.capture; break; case 'weixin': return false; break; case 'iPhone': return false; break; default: return false; break; &#125; &#125; &#125;, methods: &#123; isWQ: function () &#123; var _this = this; var ua = window.navigator.userAgent.toLowerCase(); if (ua.indexOf('qq') &gt; -1) &#123; if(/iPhone/i.test(ua))&#123; _this.isqq = "iPhone"; return false; &#125; if (/nettype/i.test(ua)) &#123; //微信或者QQ if (/micromessenger/i.test(ua)) &#123; //微信 _this.isqq = "weixin"; return true; &#125; else &#123; //QQ _this.isqq = "qq"; return true; &#125; &#125; else &#123; //QQ浏览器 _this.isqq = "QQliulanqi"; return false; &#125; &#125; else &#123; //其他浏览器 _this.isqq = ""; return false; &#125; &#125; &#125;&#125;Vue.component('camera', camera);// getusermedia recorder_videovar recorder_video = &#123; template: '&lt;div class="recorderwrap"&gt;'+ '&lt;div class="describewrap" v-show="active"&gt;'+ '&lt;p class="item1"&gt;&#123;&#123;message.text10&#125;&#125;&#123;&#123;count&#125;&#125;s&lt;/p&gt;'+ '&lt;/div&gt;'+ '&lt;video @touchmove.prevent ref ="video" v-show="active" controls autoplay playsinline&gt;&lt;/video&gt;'+ '&lt;div class="btnwrap"&gt;&lt;button @click="start" class="bluebtn" &gt;&#123;&#123;message.text8&#125;&#125;&lt;/button&gt;'+ '&lt;button @click="nextstep" class="bluebtn" :disabled="savebtn"&gt;&#123;&#123;message.text9&#125;&#125;&lt;/button&gt;&lt;/div&gt;'+ '&lt;/div&gt;', props:[ 'constrains', 'recordtime', 'message' ], data:function () &#123; return &#123; mediaRecorder:'', chunks:[], status:'inactive', mediaStreamTrack :'', savebtn:true, count:'' &#125; &#125;, computed:&#123; 'option':function () &#123; return this.constrains || &#123; video: true ,audio: &#123;echoCancellation:true&#125;&#125;; &#125;, 'videoUrl':function () &#123; return window.URL || window.webkitURL || window.mozURL || window.msURL; &#125;, 'time':function () &#123; return this.recordtime || 5000; &#125;, 'active':function () &#123; switch (this.status) &#123; case 'recording': this.savebtn = true; return true; break; case 'inactive': return false; break; default: break; &#125; &#125; &#125;, created:function () &#123; this.count = this.time/1000; &#125;, methods:&#123; getUserMedia:function (constrains,success,error) &#123; if(navigator.mediaDevices.getUserMedia)&#123; //最新标准API navigator.mediaDevices.getUserMedia(constrains).then(success).catch(error); &#125; else if (navigator.webkitGetUserMedia)&#123; //webkit内核浏览器 navigator.webkitGetUserMedia(constrains).then(success).catch(error); &#125; else if (navigator.mozGetUserMedia)&#123; //Firefox浏览器 navigator.mozGetUserMedia(constrains).then(success).catch(error); &#125; else if (navigator.getUserMedia)&#123; //旧版API navigator.getUserMedia(constrains).then(success).catch(error); &#125; &#125;, start:function () &#123; if(!(navigator.mediaDevices || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia))&#123; openDialog(&#123; cht:'您的瀏覽器不支持拍攝視頻功能', chs:'您的浏览器不支持拍摄视频功能' &#125;) return false; &#125; this.getUserMedia(this.option,this.success,this.error); &#125;, setData:function () &#123; var _this = this; _this.mediaRecorder.ondataavailable = function(e) &#123; _this.chunks.push(e.data); _this.stop(); &#125; _this.mediaRecorder.onstop = function(e) &#123; var blob = new Blob(_this.chunks, &#123; 'type' : 'video/mp4' &#125;); _this.chunks = []; _this.blobToDataURL(blob,function (data) &#123; var reg = /^data:(video)\/(image|mp4|quicktime|webm|3gpp);base64,/; var str = data.replace(reg, ""); _this.savebtn = false; _this.message.text8 = lang=='cht'?'重新錄制':'重新录制'; _this.$emit('ondata',str); &#125;); &#125; &#125;, stop:function () &#123; var video = this.$refs.video; video.pause(); this.mediaRecorder.stop(); this.mediaStreamTrack &amp;&amp; this.mediaStreamTrack.stop(); this.status = this.mediaRecorder.state; &#125;, blobToDataURL:function (blob,callback) &#123; var a = new FileReader(); startwait(); //开起loading的方法 a.onload = function (e) &#123; stopwait();//关闭loading callback(e.target.result); &#125; a.readAsDataURL(blob); &#125;, success:function (stream) &#123; var _this = this; _this.mediaRecorder = new MediaRecorder(stream); _this.mediaRecorder.start(this.time); _this.mediaRecorder.stream = stream; _this.status = _this.mediaRecorder.state; _this.mediaStreamTrack = typeof stream.stop === 'function' ? stream : stream.getTracks()[1]; var video = this.$refs.video; if ("srcObject" in video) &#123; video.srcObject = stream &#125; else &#123; video.src = window.URL &amp;&amp; window.URL.createObjectURL(stream) || stream &#125; video.muted=true; video.volume=0; video.play(); _this.setData(); this.countfn(); &#125;, error:function (err) &#123; if(err.name == 'NotAllowedError')&#123; openDialog(&#123; cht:'您的瀏覽器拍照權限被禁止', chs:'您的浏览器拍照权限被禁止' &#125;) &#125;else if(err.name == 'NotReadableError')&#123; this.constrains = &#123; video: true ,audio: false&#125;; this.start(); &#125;else&#123; openDialog(&#123; cht:'您的瀏覽器不支持拍照功能', chs:'您的浏览器不支持拍照功能' &#125;); &#125; &#125;, nextstep:function () &#123; this.$emit('next'); &#125;, countfn:function () &#123; var _this = this; var num = _this.count; var time = setInterval(function () &#123; _this.count--; if (_this.count&lt;=0) &#123; clearInterval(time); setTimeout(function () &#123; _this.count = num; &#125;,1000); &#125; &#125;,1000); &#125; &#125;&#125;Vue.component('recordervideo', recorder_video); 下面是获取input file文件的base64，图片压缩方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// 获取readerwlzCamera.prototype.readURL = function (input, callback,changehook) &#123; var _this = this; if (input.files &amp;&amp; input.files[0]) &#123; changehook(); var reader = new FileReader(); reader.readAsDataURL(input.files[0]); reader.onload = function (e) &#123; stopwait(); if (_this.prebox) &#123; // 如果有预览盒子 添加预览图片 var prebox = document.querySelector(_this.prebox); var img = document.createElement('img'); img.src = e.target.result; prebox.append(img); img.setAttribute('data-bind', _this.prebox); &#125; callback(e.target.result, e) &#125; &#125; else &#123; if (_this.prebox) &#123; document.querySelector('[data-bind = "' + _this.prebox + '"]').remove(); &#125; callback(null); &#125;&#125;wlzCamera.prototype.init = function (callback,changehook) &#123; changehook = changehook?changehook:function () &#123;startwait();&#125; var _this = this; // 绑定事件回调 var el = document.querySelector(this.fileInput); el.onchange = function (e) &#123; _this.readURL(el, function (v, e) &#123; callback(v, e); &#125;,changehook); &#125;&#125;// 图片压缩方法wlzCamera.prototype.compress = function (option,base64,callback) &#123; if(base64.match(/video/))&#123; callback(base64); return false; &#125; var quality = option.quality || 0.6; var max = option.max; var sacle = option.sacle || 1; var result = base64; var maxheight = option.maxheight || 1000; var img = new Image(); img.src = base64; // 如果质量为1，则不进行压缩。 if(quality == 1)&#123; callback(result); return false; &#125; img.onload = function () &#123; // 生产比例 var width = img.width; var height = img.height; // 重新计算宽高 默认最大1000 while (height*sacle&gt;maxheight) &#123; sacle -= 0.01; &#125; width*=sacle; height*=sacle; // 生产cavas var canvas = document.createElement('canvas'); var cxt = canvas.getContext('2d'); canvas.width = width; canvas.height = height; cxt.drawImage(img,0,0,width,height); result = canvas.toDataURL('image/jpeg',quality); if (max) &#123; while (result.length / 1024 &gt; max) &#123; quality -= 0.01; result = canvas.toDataURL("image/jpeg", quality); &#125; &#125; callback(result); &#125;&#125;// 封装成一个获取base64方法function h5getBase64(option, callback,changehook) &#123; var inputname = option.inputname; if (h5getBase64[inputname]) &#123; //单例 return false; &#125; // 实例 var _self = option.app; // 获取相册base64 和预览的方法 var reg = option.reg; h5getBase64[inputname] = new wlzCamera(&#123; fileInput: inputname, // prebox:'.box' &#125;); h5getBase64[inputname].init(function (v, e) &#123; var str; if (!v) &#123; return; &#125; h5getBase64[inputname].compress(option,v,function (result) &#123; str = result.replace(reg, ""); callback(result, str, _self, e); &#125;); &#125;,changehook);&#125;// 页面用法大致如下// camera 用法 // 初始化 拍照 需要的参数var option = &#123; app: app, inputname: 'input.shiping', reg: /^data:(video|image)\/(image|mp4|quicktime|png|gif|jpeg|jpg|3gpp);base64,/&#125;h5getBase64(option, function (v, str, _self,e) &#123; // _self 是传进来的实例对象。 // dosthing // ajax&#125;);// android 是否是安卓 isAppH5是不死APPH5 !$.arrayInclude(channel) 是不是原生APP 这些变量主要是处理什么时候隐藏彼此，调用那个组件 so 自己定义好就可以了，这里只是个思路。&lt;recordervideo v-if="android &amp;&amp; !isAppH5" :message="&#123;&#125;" @next="sendajax" @ondata = "ondata"&gt;&lt;/recordervideo&gt;&lt;camera v-else-if="!$.arrayInclude(channel)" :_class="'shiping'" :name="'shiping'" :accept="'video/*'" :capture = "'user'" :direct = "true" &gt;&lt;/camera&gt; 有问什么问题可以github上联系我，或者邮箱等。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容问题]]></title>
    <url>%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录下浏览器可能会碰到的坑 UC浏览器无法加载CSS uc浏览有一个广告拦截模式，它可能会错误的把css屏蔽掉。]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式支持您在运行时选择算法。代码客户端可以使用同一个接口来工作，但是它却根据客户正在试图执行任务的上下文，从多个算法中选择用于处理特定任务的算法。 数据验证实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 数据验证对象function Validator(&#123;config=&#123;&#125;&#125;=&#123;config:&#123;&#125;&#125;) &#123; this.config = config; this.message = [];&#125;Validator.prototype.validate = function (data) &#123; // 重置所有消息 this.message = []; for (const key in data) &#123; if (data.hasOwnProperty(key)) &#123; const value = data[key]; let checkers = this.config[key]; for (const checker of checkers) &#123; if (!checker) &#123; // 没有验证则不需要验证 continue; &#125; let checkType = this[checker]; if (!checkType) &#123; throw &#123; name: 'ValidationError', message: 'No handler to validate' + checker &#125;; &#125; // true 验证ok let result_ok = checkType.validate(data[key]); if (!result_ok.pass) &#123; this.message.push(&#123;...result_ok,instructions:checkType.instructions&#125;); &#125; &#125; &#125; &#125; return this.hasError();&#125;// 帮助方法Validator.prototype.hasError = function () &#123; return this.message.length !== 0;&#125;Validator.prototype.isEmpty = &#123; validate: function (data) &#123; let Questionns = data.Questionns; for (let i = 0; i &lt; Questionns.length; i++) &#123; const question = Questionns[i]; // 如果不是必要则不需要验证 if (question.IsMust !=1) &#123; continue; &#125; let checked = false; for (let j = 0; j &lt; question.Answers.length; j++) &#123; const answer = question.Answers[j]; if (answer.IsSelect=="true") &#123; checked = 1; &#125; for (let k = 0; k &lt; answer.remarklist.length; k++) &#123; const remark = answer.remarklist[k]; if (remark.ismust &amp;&amp; (answer.OptionContent.split('@')[k+1]==''||answer.OptionContent.indexOf('@')==-1) &amp;&amp; answer.IsSelect=="true") &#123; checked = 2; &#125; &#125; &#125; if (checked &amp;&amp; checked!=2) &#123; continue; &#125;else&#123; // 没有勾选返回 return &#123; checked, pass:false, data:question &#125; &#125; &#125; return &#123; pass:true &#125; &#125;, instructions: 'isEmpty'&#125;]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2FjavascriptModel%2F</url>
    <content type="text"><![CDATA[期望结果： 123var uni = new universe();var uni2 = new universe();nni === uni2 // true; 需要保证完全相等，且指针不变。 实现方法：可以使用，静态属性缓存实例。 123456789function Universe() &#123; if(typeof Universe.instance === "object")&#123; return Universe.instance; &#125; this.name = '小明'; this.age = 8 Universe.instance = this; // 隐式返回this;&#125;]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式,它通常在类或者类的静态方法中实现，具有以下目标 当创建相似对象时，执行重复操作。 在编译时不知道具体类型的情况下，为工厂客户提供一种创建对象的接口。通过工厂方法(或者类)创建的对象在设计上都继承了相同的父对象这个思想，它们都是实现专门功能的特定子类。有时候公共父类是一个包含了工厂方法的同一个类。 期望结果： 123456var car = CarMaker.factory('benz');var motor = CarMaker.factory('dajiang');var bike = CarMaker.factory('fenghuang');car.drive(); // 4个轮子motor.drive(); //2个轮子bike.drive(); //2个轮子 需要保证完全相等，且指针不变。 实现方法： 123456789101112131415161718192021222324252627282930313233// 父构造函数function CarMaker()&#123;&#125;// a method of the parentCarMaker.prototype.drive = function()&#123; return `Vroom,I have $&#123;this.wheel&#125; wheels`;&#125;//静态工厂方法CarMaker.factory = function(type)&#123; var constr = type,newcar; // 如果构造函数不再在，则报错 if(typeof CarMaker[constr] !=="function")&#123; throw&#123; name:'Error', message:constr+"doesn't exist" &#125; &#125; // 继承父类 CarMaker[constr].prototype = new CarMaker(); newcar = new CarMaker[constr](); return newcar;&#125; // 定义不同类型的车子CarMaker.car = function()&#123; this.wheel = 4;&#125;CarMaker.motor = function()&#123; this.wheel = 2;&#125;CarMaker.bike = function()&#123; this.wheel = 2;&#125;]]></content>
      <categories>
        <category>书籍笔记</category>
        <category>javascript模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS倒计时页面刷新]]></title>
    <url>%2FJS%E5%80%92%E8%AE%A1%E6%97%B6%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[写了个倒计时的插件，页面刷新倒计时仍然有效，利用localStorage储存。下面贴上代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function timer (&#123;id,count=60&#125;=&#123;&#125;,callback) &#123; this.id = id; this.restnum = count; this.num = count; this.callback = callback;&#125;timer.prototype.count= function () &#123; // 进入倒计时 let done = false; this.callback(this.num,done); let time = setInterval(() =&gt; &#123; this.num--; if(this.num&lt;=0)&#123; clearInterval(time); done = true; localStorage.removeItem(this.id) &#125; this.callback(this.num,done); &#125;, 1000);&#125;timer.prototype.start = function () &#123; // 设置时间 let time = new Date().getTime(); localStorage.setItem(this.id,time); // 重置计数 this.num = this.restnum; // 启动计时 this.init();&#125;timer.prototype.init = function () &#123; // 获取localnum和loacltime let time = localStorage.getItem(this.id); if(!time)&#123; return false; &#125; let now = new Date().getTime(); let dvalue = (now - time)/1000; if(dvalue&gt;this.num)&#123; localStorage.removeItem(this.id); return false; &#125; this.num = parseInt(this.num - dvalue); this.count(); // 根据时间 判断 num是否小于0。 // 小于0 过期清除停止倒计时,清除时间 // 大于0 计算正确 num // 开始倒计时&#125;module.exports =&#123; timer&#125; 用法如下:不同元素用同一个ID参数即可。12345678/** * num：倒计时数值 * done：是否倒计时完成 */let timer = new timer(&#123;id:'time',count:this.count&#125;,function (num,done) &#123; &#125;); this.timer.init(); 注意在vue 下直接绑定start函数是注意this的指向 12@click="timer.start()"// start一定要带() 不然start函数里的this指向window而不是实例timer]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js执行顺序详解]]></title>
    <url>%2Fjs%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.下面这段代码执行顺序会是怎样的呢？和文件大小有关？读取时长有关？ 123456789101112131415161718192021&lt;script&gt; var aa = 1; var loadFiles = document.getElementById("loadFiles");//获取id为loadFiles的input对象 function handleFiles(files)&#123; if(files.length)&#123; var file = files[0]; var reader = new FileReader(); reader.readAsText(file); reader.onload = function()&#123; aa = 2; console.log(aa); &#125;; console.log(aa); &#125; &#125;&lt;/script&gt;&lt;body&gt;&lt;input type="file" id='loadFiles' onchange="handleFiles(this.files)" /&gt;&lt;div id="filesContent" &gt;&lt;/div&gt;&lt;/body&gt; 解答：跟文件大小、读取时间耗时长短无关。先输出1后输出2是必然的！ 证明如下： 首先写一个阻塞函数，用于阻塞JS执行线程一段时间：1234function block(delay) &#123; var end = +new Date() + delay; while(+new Date() &lt;= end)&#123;&#125;&#125; 然后，把它加到你的代码中：1234567reader.readAsText();block(5000);reader.onload = function() &#123; console.log(2);&#125;;block(5000);console.log(1); 结果是什么？是不论你阻塞多长时间，结果都是先输出1，后输出2。 结论就是： onload回调函数被设计成了不在当前这一轮事件循环调用。 2.下面关于定时器，和promise的执行顺序是什么样的呢？抛出题目先。1234567891011121314151617181920212223242526(function() &#123; setTimeout(() =&gt; &#123; console.log(0); &#125;); new Promise(resolve =&gt; &#123; console.log(1); setTimeout(() =&gt; &#123; resolve(); Promise.resolve().then(() =&gt; console.log(2)); console.log(3); &#125;); Promise.resolve().then(() =&gt; console.log(4)); &#125;).then(() =&gt; &#123; console.log(5); Promise.resolve().then(() =&gt; console.log(8)); //这句是多加的 setTimeout(() =&gt; console.log(6)); &#125;); console.log(7);&#125;)(); 答案详解参考]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习备忘]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[背景希望通过备忘来复习通过零散的时间学习到的东西，并及时做下笔记，待有时间来复习和手动实现。 日志模板123456789### Date#### 内容#### 来源#### 关联--- 第1天 2019年5月6日00:29:47内容VUE 组件封装，API的模拟，ajax的封装及代理,路由的重新定向,公共变量的引入,顶部导航条组件封装,localstore配合axios处理session，以及axios处理统一请求头。 来源马轮的SFA的视频教学 关联API模拟表单校验插件马伦视频教程]]></content>
      <categories>
        <category>技术</category>
        <category>日常备忘</category>
      </categories>
      <tags>
        <tag>技术备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[english-notes]]></title>
    <url>%2Fenglish-notes%2F</url>
    <content type="text"><![CDATA[开始时间：2019-5-1 背景笔记来源：100天英语挑战中的英语笔记 额外的补充mathjax语法格式 音标123456789101112131415元音：[i] [ɪ] [e] [ɛ] [æ] 嘴型 横紧→竖长[ɑ] [ʌ] [ə] [ɚ] [ɝ] 嘴型长得最大的是[ɑ][o] [ɔ] [u] [ʊ] o→u[aɪ] [aʊ] [ɔɪ]辅音：清： p t k f s θ ʃ tʃ浊： b d g v z ð ʒ dʒ清： h浊： m n ŋ l r w j元音前后读音有变化的音标：m n l rm 嘴巴闭。 (么)n 舌头向上，嘴巴不闭。 （n）ŋ 舌头向下，嘴巴不闭。l e o 之间的发音girl [gɜrl] (l) 复习元音复习辅音国际音标和KK音标的区别 发音知识辅音部分嘴型相同，分为浊，和清。 拼读原则： 音标中没有重音符号时元音四声辅音轻声 音标分割方法：元音前连接一个辅音划分一个音节，前面两个辅音的时候单独发音grill[grɪl] bunny[bʌ ni:] 元音前后读音有变化的音标：m n l r 拼读变化[s] + [p] [t] [k] 浊化元音 [ə] 在单词音标结尾时，会发音成较轻较短促的a音[br] [pr] [kr] [gr] 辅音 + 辅音 + 元音这里我们列出「br + 母音」的发音例词，请多做发音与听音练习，习惯这个发音形态。发音技巧：先拼音 r + 元音，之后 b 音加进來，三个音一起发音，b 不是单音的发音方式，请注意。 句子拼读原则强调单词读重音 过去式 ed 浊后[d]清后[t] 例句 Tim grilled[gril][d] six fish. May baked[bek][t] eight cakes. 复数 es [iz] 例句 Watches are not clocks. A wacth is not a clock. 复数 s /ts/ boat oa一起a不发音 ride[raɪd] rides 浊音念/z/ /dz/ house[haus] houses[hauzɪz] 加上复数s s变z es变/iz/ toy[tɔɪ] 复数 toys 元音结尾复数加s 不用去y加iesplays[plez] 元音结尾s 变/z/ aeiou 结尾y直接加scry[kraɪ] cries 例句 Those owners rowed[d] old boats[bot][s] /ts/ gh不发音 catch[kætʃ] 例句 Paul caught[kot] all balls. [ʊ] wooden[wudn]dn中间少了个 ɚ 例句 A wolf pulled wooden hooks. [u] ew 发u 例句 Sue blew[blu] two blue[blu] balloons [ə] the[ðə] the 后面接元音开头发[ðɪ] the apple 元音aeiou 三个元音在一个单词里面 其中一个不发音 polite[pɚlaɪt] 单词末尾e不发音 自然拼读oa [o] coat [kot]Aa [æ] bag [bæg]; cat [kæt]; jam [dʒæm]Bb [b] bat [bæt]; bed [bæd]; boy [bɔɪ]Cc [k] can [kæn]; car [kar]; coat [kot]Dd [d] dog [dɔg]; door [dɔr] oo$^③$; duck [dʌk]Ee [ɝ] bell[bɝl]; desk [dɝsk]; red [rɝd]Ff [f] fac$(e)_×$ [fes]; fan [fæn]; food[fud] oo$^③$Gg [g] game [gem] a~e$^②$; girl [gɝl]; egg [ɛg]Hh [h] hat [hæt]; hair [hɛr]; hope [hop] oo$^{①③}$Ii [ɪ] bib [bɪb]; kiss [kɪs]; six [sɪks]Jj [dʒ] job [dʒɑb]; July [dʒulaɪ]; jump [dʒʌp]Kk [k] key [ki]; king [kɪŋ]; kite [kaɪt]Ll [l] lake [lek]; leaf [lif]; light[laɪt]Mm [m] man [mæn]Nn [n] name [nem]Oo [o] cold [kold] ni$(gh)_x$tPp [p] pig [pɪg]Qq [kw] quit[kwɪt]Rr [r] rabbit [ræbɪt]Ss [s] sale [sel]Tt [t] table [tebl]Uu [ʌ] cup [kʌp]Ww [w] watch [watʃ]Xx [ks] box[baks]Yy [j] yellow [jɛlo]Zz [z] zero [zɪro] e 结构 末尾不发音 $^①$ a~e 结构 e在末尾不发音 a 发 IPA [ei] $^②$ oo 结构 [u] [o] [ɔ] $^③$ ing 结构 [ɪŋ] $^④$ dog [ɔ] god[a] know [no] kn在一起k不发音 [i] =&gt; e:we [wi]; me [mi] e:feet[fit]; see [si] ea:heat[hit]; fleat[fit] y:lady[ladi]; easy[izi] ie:field[fild]; thief[θif] [ɪ] =&gt; i:dig[dɪg];milk[milk] y:gym[dʒɪm];dirty[dɝtɪ] [e] =&gt; a~e:name[nem];lake[lek] ai:nail [nel];rain[ren] ay:day[de];way[we] ea:steak[stek];great[gret] [ɛ] =&gt; e:bed[bɛd]; ea:bread[brɛd]; e~e:sense[sense] [æ] =&gt; a:cat [kæt]; [a] =&gt; o:lock[lak]; a:watch[watʃ]; [o] =&gt; o:go[go] o~e:hope[hop] ow:know[no] oa:boat[bot] oe:toe[to] [ɔ] =&gt; o(r):for[fɔr] a(l):talk[tɔk] l不发音 a(ll):ball[bɔl] au:cause[kɔz] aw:saw[sɔ] [ʊ] =&gt; oo:book[bʊk] u:put[pʊt] [u] =&gt; oo:moon[mun] u:ruby[rubɪ] ue:blue[blu] ew:flew[flu] u~e:rule[rul] [ʌ] =&gt; u:duck[dʌk] o:son[sʌn] ou:double[dabl] [ə] =&gt; a:ago[əgo] e:quiet[kwaɪt] i:direct[dərɛkt] o:today[təde] u:circus[sɝkəs] [ɚ] =&gt; er:after[æftɚ] or:tailor[telɚ] [ɝ] =&gt; ur:burn[bɝn] er:clerk[klɝk] ir:bird[bɝd] 重点 er在重音节[ɝ]轻音节[ɚ] [aɪ] =&gt; i~e:bike[baɪk] y:cry[kraɪ] i:child[tʃaɪld] ie:die[daɪ] igh:night[naɪt] [aʊ] =&gt; ou:cloud[klaʊd] ow:cow[kaʊ] [ɔɪ] =&gt; oi:coin[kɔɪn] oy:boy[bɔɪ] 字音[k] =&gt; c:cat[kæt] k:key[ki] ck:luck[lʌk] lk:talk[tɔk] q:(在u之前):queen[kwin],quit[kwɪt] [g] =&gt; g:在a o u 或其他字音前 gate[get] 在字尾:bag[bæg] gh:ghost[gost] [f] =&gt; f:fan[fæn] ff:muffin[mʌfin] ph:phone[fon] if:shelf[ʃɛlf] gh(在au,ou)之后:laugh[læf] [s] =&gt; C(在i,e,y之前) circle[sɝkl] s:sun[sʌn] ss:boss[bɔs] [ʃ] =&gt; sh:shark[ʃark]重点 s和h出现在不同音节，则不发[ʃ]如:dishonor[dɪsanɚ] ti:nation[neʃɚn] sci:conscience[kanʃəns] ch:(常出现在法国字演变成的英文字中) chef[ʃɛf] ssi:mission[mɪʃɚn] s:sure[ʃʊr] si:mansion[mæɚn] [θ] =&gt; th:thin[θɪn] [ð] =&gt; th:that[ðæt]重点但 Thomas[taməs] [ʒ] =&gt; si:vision[vɪʒən] s:pleasure[plɛʒə] g:rouge[ruʒ] [tʃ] =&gt; ch:cheese[tʃiz] t:nature[netʃɚ] tch:match[mætʃ] [dʒ] =&gt; g(在i,e,y之前):gentle[dʒɛntl] j:just[dʒʌst] dge:bridge[brɪdʒ] d:graduation[grædʒueʃɚn] [h] =&gt; h:hat[hæt] wh:who[hu] [n] =&gt; n:can[kæn] nn:runner[rʌnɚ] kn:knife[naɪf] [ŋ] =&gt; n(在k之后):pink[pɪŋk] ng:ring[rɪŋ] 重点ng还有[ŋg]的音:finger[fiŋgɚ] kangaroo 很少单词 [j] =&gt; y:yellow[jɛlo] i:onion[ʌnjɚ] 字音字母省略不发音b =&gt; 在t或m前不发音:debt[dɛt] thumb[θʌm]c =&gt; ck的c不发音:pick[pɪk]偶尔在s之后不发音：scene[sin]g =&gt; 在n之前不发音：gnash[næʃ] designgh =&gt; 在t之前不发音：bought[bɔt] caughth =&gt; 在r或k之后不发音:rhyme[raɪm]=&gt; 和母音字母同时出现在字尾:oh[o]=&gt;偶尔在字音和非重音节母音之间不发音：shepherd[ʃɛpɚd]=&gt;偶尔在字首不发音:hour[aʊr],honor[ɑnɚ]=&gt;在ex之后：exhaust[ɪgzɔst]k =&gt;和n同时出现在字首时不发音:know[no]l =&gt;在alk.alm.alf中不发音：talk[tɔk]=&gt;在ould中不发音：should[ʃʊd]n =&gt;和m同时出现时不发音：autumn[ɔtɚm]p =&gt;和n.s.t之前不发音：psychology[saɪkalədʒɪ]S =&gt;偶尔在i之后不发音:island[aɪlənd]=&gt;在Arkansas字尾的S：Arkansas[arkɔnsɔ]t =&gt; ~sten 及 ~stle中的t 不发音fasten[fæsn] castle=&gt;源自法国的t不发音:depot[dipo] balletu =&gt; 偶尔在g或q之后不发音：guard[gard]w =&gt;和r同时出现在字首时不发音=&gt;在某些单子中不发音:two[tu]notebook t省略掉 音的变化 字音+母音 前面的字尾是字音，后面的字首是母音时，可以连读。例子：give up [vʌ]; turn off [gau]Tell her I miss her. h不发音 其他链接 字音＋字音 前面字尾的音和后字字首的子音相同，前面的子音省略。 子音[p] [b] [t] [d] [g] [f] [v] 要轻音化 例子: sit down, credit card ,hot dog I wa~~s~~ so happy. /He nee(ds a) lo(t o)~~f~~ money. I ~~h~~ave go~~t~~ t(o=&gt;a) go. =&gt; I have gotta go. Do you want to dance? =&gt; Do you wanna dance? 母音＋母音 前字字尾的母音和后字字首的母音中，会多出[w],[j]的发音.例子: Do I?/You’re so honest./He is a boy. T.D.S.Z + Y [t] [d] [s] [z] 结尾 + 字，接上Y开头的字，会产生下列音变。(1)T+Y [tʃ]例子：Can’t you do it?/I’ll let you know.Is/z/ /ð/tha(t y)our car?/No(2)D+y [dʒ]例子：Did you love me?/Could you tell me?Where did you buy it?(3)S+Y [ʃ]例子：God bless you./Can you dress yourself? I miss you.(4)Z+Y [ʒ]例子:How was your vacation? He say’s you’re good.Where your sister?这些变化是根据单词发音的组合而不是单纯的看单词的组合。 /z/+your [ʒ]]]></content>
      <categories>
        <category>100天挑战</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100天英语挑战 (第一轮)]]></title>
    <url>%2Flearn-english%2F</url>
    <content type="text"><![CDATA[主要承诺：每天进行英语学习 开始时间：2019-5-1 背景首先我是一名程序员，在学习技术和借鉴别人的经验，英文资源还是有很多质量比较高的。从长远来看可以学习一些其他方面的书籍，还可以和使用英语的人交流想法或者是交朋友，我在开始自学编程的时候是在freecode的一个网站。在里面认识了一个优秀的人，也是在她的影响下以及我觉得写博客也算是对学习的一个反馈，说不定以后要写双语版呢.. 规则 每天进行英语学习 我将在这里跟踪我的进展并推送给GitHub。 如果出现重要的事情，我会跳过这一天不算在100天之中。 阶段 1天 确定好学习资料 谢孟媛老师的发音篇 学习路径：发音-单词-语法-句子-文章 7天 30天 60天 90天 100天 额外的补充 不要连续两天跳过，并且两周之内跳过一天 日志模板123456789### 第N天#### 今天的进步#### 思想和情绪#### 明天的计划--- 第1天今天的进步看完谢孟媛老师的发音篇对KK音标有一个完整的熟悉 思想和情绪完成这个100天挑战，合理的计划是很必要的，虽然感觉学的量还可以，但在休息上没有做到很好的权衡。这对于长期是没有意义的。还需要合理的平衡时间。希望通过这个计划记录每一天的作息时间，在这个时间后半个小时内必须入睡。 睡眠：2019年5月2日02:16:14 明天的计划学习自然拼读复习英语笔记音标 第2天今天的进步2看完谢孟媛老师的发音篇对自然拼读有了解 思想和情绪2做下笔记，今天早点睡睡眠：2019年5月2日21:00:13 明天的计划2学习自然拼读复习英语笔记音标 第3天今天的进步3背诵牛津高一 100单词 思想和情绪3学了音标，和自然拼读单词还是好记忆写，虽然还是会转头就忘，试试艾宾斯记忆法，多多复习。睡眠：2019年5月3日11:45:19 明天的计划3100单词复习英语笔记音标 第4天：2019年5月5日03:41:25今天的进步4学习了谢孟媛老师的自然发音,单词重轻音节的读法，并做了笔记。比较单词软件后，觉得百词斩应该比较适合。 思想和情绪4今天睡眠有点晚 明天的计划4开始用百词斩背诵单词，把剩下的两个小时的发音课完成。 第5天：2019年5月5日18:06:59今天的进步5学习了谢孟媛老师的发音课的最后一个视频,并做了笔记。 思想和情绪5今天早点睡觉,但是今天下午3点才睡醒的。以后放假也要作息正常。 明天的计划5正式用百词斩背诵单词，结合例句等，配合笔记，学习英语。 第6天：2019年5月6日22:19:23今天的进步6用百词斩学习单词，由于基础单词较多，感觉过的很快。背了几个单词比如,wear穿,autumn,kick,tail,pet,bite,sence,favorite,tongue,sweater，grade, 思想和情绪6加油 明天的计划6正式用百词斩背诵单词，复习单词。]]></content>
      <categories>
        <category>100天挑战</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>100天挑战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刻意练习]]></title>
    <url>%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[《刻意练习》 | 成甲解读关于作者作者艾利克森，是佛罗里达州立大学心理学教授，也是“刻意练习”法则的研创者。他专注于研究体育、音乐、国际象棋、医学、军事等不同领域中的杰出人物是如何获得杰出表现的，以及“刻意练习”法则在其中的作用。 关于本书《刻意练习》是学习领域的一本经典著作，它不仅帮你理清了很多关于学习中模糊的概念，甚至还颠覆了一些关于学习的传统认知，对于在任何行业或领域中希望提升自己的每个人，“刻意练习”是迄今为止发现的最强大的学习方法 自己的总结 好的导师，一流的教材。 有目的的训练比如自己手写一个设计模式（合理的目标也能帮助自己走出舒适区进行有效训练）。根据自己的理解，列举其重点，然后校正的练习(相当于反馈)。 给自己定个目标成为大牛。动手能力强的那种。 核心内容第一，为什么训练可以铸就天才？天才不是天生的吗？第二，训练分为有效训练和无效训练，那应该如何区分呢？第三，迄今为止最强大最有效的学习方法是刻意练习。刻意练习究竟是什么？ 前言你好，欢迎每天听本书。今天我们要分享的书叫《刻意练习》，副标题是“如何从新手到大师”。有一个广为人知的观点叫“一万小时天才定律”，但实际上1万小时并不是放之四海而皆准的真理，《刻意练习》的作者艾利克森告诉我们：只有在刻意练习下1万小时才有用。艾利克森，是佛罗里达州立大学心理学教授，也是“刻意练习”法则的研创者。他主要研究各个领域中的杰出人物是如何获得杰出表现的，比如体育、音乐、国际象棋、医学、军事等领域，他发现这些杰出人物的成就都有一个共同点，那就是遵循了“刻意练习”法则。《刻意练习》这本书，2016年一出版就立刻成为畅销书，销量惊人。我自己一直研究知识管理，在我看过的所有关于高效学习方法的书中，可以说《刻意练习》是对训练方法讲得最透彻最深刻的一本书。这本书不仅帮我们理清了很多模糊的概念，甚至颠覆了一些关于学习的认知和观点。因此，这本书一定会成为学习领域的经典著作。这本书中有三个观点给我们非常大的启发：第一，为什么训练可以铸就天才？天才不是天生的吗？第二，训练分为有效训练和无效训练，那应该如何区分呢？第三，迄今为止最强大最有效的学习方法是刻意练习。刻意练习究竟是什么？这三个观点让我们一一来看。 第一部分首先来看，为什么说通过训练可以铸就天才。莫扎特是大家公认的一位音乐天才，他在7岁的时候就举行了大型的音乐会，让音乐界广为震惊，不过这还不算什么，更令人震惊的是，莫扎特在他4岁的时候就能够分辨任何音乐的音调，甚至是像声音的调子，比如时钟报时的音调，甚至人打喷嚏的音调，这种能力是极其罕见的，大约在每一万人当中，只有一个人具有这种完美音高的能力。莫扎特的这种能力一直作为证明“天赋是与生俱来的”绝好例子。似乎，天才之所以是天才，就是因为有天赋异禀的能力。真是这样们？在2014年日本一位心理学家做了这么一个实验，他招募了24个两到六岁之间的孩子，在训练他们一年以后，这24个孩子全部具有了完美音高的能力。也就是说经过训练，也可以获得和天才一样的表现。作者分析说，莫扎特所谓的天赋很可能也是训练的结果。要知道早在莫扎特4岁的时候，他父亲就已经全职教他音乐了，每天音乐训练的强度，比那24个小孩子还要高，是训练铸就了天才。过去我们觉得，在一些领域，有些人做得好就是有天赋的，另一些人就是没天赋的；有天赋的被挖掘出潜能就可以成功，没天赋的你再练也没用，“不是这块料”；什么叫“天赋”啊，什么叫“天才”啊，意思就是天生的嘛。可是作者打破了这个观点，他说，所谓的潜能全部是可以被锻炼出来的，就像跑步健身能够锻炼肌肉一样，用正确的方法就可以训练出潜能。这个观点，完全颠覆了传统认知。人的身体和大脑有极强的适应性，如果通过刻意的训练，就能够极强地改变身体的适应能力。比如你觉得人类做俯卧撑的世界纪录是多少？500还是1000个？在1980年有一个日本人做到了10507个，夸张吗？这还不算什么，在1993年的时候，美国有一个人只花了21个小时就做了46001个俯卧撑。天哪，人身体的极限究竟在哪里？通过训练可以让身体素质强大到21个小时做4万多个俯卧撑。其实大脑也一样，大脑经过刻意练习之后，也能够发展出过去不具备的潜能。在伦敦，由于道路条件极其复杂，GPS 系统都会陷入混乱，所以要在伦敦做一名出租车司机，必须通过被称为世界上最难的测试考核。而为了通过出租车测试，司机必须进行大量的高强度训练。通过实验研究发现，经过高强度训练通过考试的司机，他们大脑中负责导航功能的海马体部位，比之前增大了不少。同样的现象也发生在盲人中，人在失明之后经过大量训练用手指触摸盲文，他们大脑相关部分也更发达了。因此作者说，我们可以通过大量的训练改变身体的适应性，我们可以创造潜能和天赋，从而创造天才。 第二部分那我们可能就会问，为什么我们也一直上学、受训练，可是却没有被训练成天才呢？作者说，那是因为训练方法不对。训练方法是分为有效的训练和无效的训练，而我们大多数人常常陷入到了无效的训练中。怎么区别有效的训练和无效的训练呢？这就是作者给我们的第二个启示。想象一下，有一个小孩子正在练习弹琴，旁边有一位老师去问他，我看你每天都训练一个小时，可是你每次测试的时候成绩都不及格，能不能解释一下原因？学生说我不知道为什么呀，我每天都在练呀。老师问，那你练了多少次？学生说十次或者二十次吧。老师再问，你弹对了多少次？学生说不知道，一次或者两次吧。老师又问那你怎么练的？学生说不知道，我只是一直在练。这样的场景熟悉吗？我们一直在写作业、一直在作题、一直在跑步、一直在下棋，可是我们既没有成为学霸、运动健将，也没有成为象棋高手，为什么？因为我们进行的是天真的练习，虽然埋头在干，但并没有进行有效的训练。事实上大多数人对练习有三种误区：第一种误区，是觉得练习可能没有太大的用，能力主要受基因限制。有人会说“我不擅长和数学打交道”“我空间想象能力比较弱”“我不认路”“我没办法做得更好”……可是作者说，其实任何人都可以通过正确的训练来改变自己，关键是要有正确的心态。第二种误区，是认为只要练习的时间足够长了，能力就慢慢好了。但是作者说，如果做的时间足够长就会足够好的话，那么就不会有那么多街边下了很多年棋，但是棋艺还是很差的臭棋篓子了。事实上以完全相同的方式一而再再而三地做某件事情，并不能提高成绩和表现，它有时候还会让我们停滞不前，并且使能力水平缓慢下降。第三种练习的误区，是认为只要努力，足够刻苦勤劳，就能提高成绩，就会更加优秀。比如，我要成为一个更优秀的经理，我要想卖出更多的产品，我要让团队合作更紧密，那么我就要更加倍地努力。可是作者说，除非你有专门的恰当的练习方法，否则即使加倍努力也不会有太大的进步。想想我们上学的时候，一定有那个最勤奋、最刻苦、最努力的坐在角落的同学，每天不停地加倍学习，可是每次考试下来成绩都很糟糕。有效的练习，不等于长时间的练习，也不等于重复的练习，只有正确方法的练习才能真正有效。那什么样的练习方法才算有效的呢？作者说这个很重要的方法叫有目的的训练。什么是有目的的训练？我们还回到刚才的例子，那个练习弹琴的小孩子，假如他的训练是这样的过程：他给自己制定一个目标，比如连续三次不犯任何错误，然后用恰当的速度弹完这首曲子，只要不符合这个标准，就去找原因。想象一下，如果这个孩子每天晚上以这样一个标准来进行训练，他的进步会不会更快一些？所以，有目的的训练，首先，是一种不断改进的做法，积小胜为大胜，积跬步致千里。其次，训练中必须专注，不能心不在焉。我们常常只是在做，而并没有认真地去思考，就像福尔摩斯说的，你只是在看，而并没有观察。另外，有目的的训练还有一个要求，那就是必须有及时反馈，如果做完了题并不知道对错，进步就非常慢。最后，还有一个很重要的因素是必须跳出“舒适区”进行训练。想象一下，一个业余的钢琴师，他十几岁就开始学琴，到他30年之后还在用同样的方式弹琴，哪怕他已经完成了1万小时的天才训练，他也不会成为天才，为什么？因为他没有走出自己的舒适区。有效的练习，是有目的地突破舒适区的训练，只有这样才能快速的进步。那是不是我们进行有目的的训练就会成为天才呢？作者说，不行。尽管有目的的训练很有效，但是它远远不够养成一个天才级水平的能力。要达到天才级的水平，需要有更高效的方法，那就是“刻意练习”。 第三部分刻意练习也是有目的练习当中的一种，是人类迄今为止发现的最有效的提升和训练技能的方法，那什么是刻意练习？在讨论刻意练习之前，我们先要问自己一个问题，我们的努力和勤奋究竟训练的是什么？训练的是速度？音乐感？还是技术？No，作者说真正训练的核心是我们的“心理表征”。什么是心理表征？这是认知心理学上的一个名词，就是说在思考事物时对应的心理结构。听起来比较抽象，我们举个例子。比如对外行的棋手来说，他看下棋就是看到一个一个的棋子在移动，而对一个大师而言，他除了看到棋面上的棋局变化之外，他还能看出两方的优势和劣势，接下来的走势，对手可能的策略以及自己可能采取的对应方案。你有没有发现，对于同样一件事，新手和专业的人员看问题的深度和高度是有差别的。换句话说他们之间的认知模块、认知结构是不一样，而这种差别就是不同的心理表征。对专家而言，他们能够把复杂的、大量的信息组成一个一个的认知模块，以这样的模块去思考和处理问题，当他在面对新情况的时候，能够快速调出过去的一些认知模块，从而在思考和解决问题上有更高效的方法。比如，踢球没经验的人就觉得足球场上双方加起来20多个人在满球场乱跑，只要是球踢到脚下就去抢就行啦，可是专业的球员会发现规律。有人专门做了实验，就是让这些专业的球员去看比赛，看一场真实的足球比赛的视频，当一个球员刚接到传过来的球时，按下暂停键，然后问实验对象说下一步这个球员会做什么行动？他是带球还是射门，还是传球？越是优秀的球员对下一步行动的判断越准确。也就是说，专业级的选手和普通的选手，天才级的人物和普通水平的人物，看问题的心理表征方面形成了关键的区别。所以，理解了这一点就理解了刻意练习的目的，我们的目的本质上就是要建立一个更强大的心理表征来思考问题，而刻意练习就是目前人类发现最强大、最高效的训练方式。那什么是刻意练习呢？作者说，从严格意义上讲，判断刻意练习有两个标准：第一，你所训练的领域是合理发展的行业，有了一整套成熟的评价标准和高效的方法；第二，你必须有一个能够给你布置训练作业和及时反馈的优秀导师。只有具备这两个条件，它才是严格意义上的刻意训练。按照这个要求，可能符合这种严格意义上的刻意训练的行业是少之又少的，也只有像国际象棋、芭蕾舞、体操、音乐表演等少数的行业。比如像小提琴训练，它就属于一个比较典型的、能够使用刻意练习的方法，它的技能组合非常标准化，演奏方法也大多是经过了数十年甚至上百年的训练和改进。如果你能够找到一个优秀的老师，他能够告诉你什么是正确的，甚至是最好的握琴方式，在跳弓的时候如何最有效地移动琴弓等等，这些方法是你自己摸索、探索训练都没有办法快速实现的，或者要走很多弯路的。所以小提琴领域，往往会有很年轻的天才型选手出现，就是因为他们有一流的导师，有已经成熟合理的技能和方法，只要持续地刻意训练、就能成为这个领域中的天才。可是我们大多数的行业其实是不符合这个标准的，很多情况下并没有最高效的方法体系和专门从事教练的一流导师。那这怎么办呢？作者说，我们可以退而求其次，尽最大可能用刻意练习的原则来训练。什么是刻意练习的原则呢？ 首先明确你的高绩效的目标，我想要实现哪方面能力的提升；其次，我们要尽可能找在这个领域中最优秀的专家，或者高手，或者经典书籍，目的是能够让我们和这个领域高水平的心理表征进行这个对比，获得高质量的反馈；第三，研究这些杰出人士或者成功案例背后可能的成功原因；第四，就是我们不断地投入时间和精力去训练。这四点就是刻意练习的原则。这个原则听起来很简单，但是如果能够切实应用，效果惊人。美国在越战早期，海军飞行员的战绩其实是很糟糕的。1968年的前5个月，美国海军击落9架越南的飞机，自己损失10来架战机。而且更夸张的是，飞行员发射了50枚空对空导弹，却没有一个打中目标。在这种情况下，美国海军不得不思考：问怎么样才能够提高飞行员的能力，让他们快速地具备一流飞行员的水准呢？这就发展出来著名的“王牌训练计划”。这个计划就是：首先把最优秀的飞行员挑选来做教官，让他们模拟越南的战斗机战术，组成红军，然后，选拔仅次于这些教官的优秀的飞行员作为学生。组成蓝军。接下来，就让红军和蓝军天天对战。因为教练组经验更丰富，所以常常把学生逼到失败的边缘，让学生在紧急、危险或者各种复杂的状况下做出战斗决策。战斗结束，当天教官就和学生沟通复盘，总结经验。教官分享他们的思考判断过程，学员寻找改进的办法。第二天，带着新办法再训练。经过这样持续反复的训练，结果到1970年的时候，这批美国海军飞行员再次投入战场，他们实现了击落12.5架的敌机，自己只损失1架飞机的惊人战绩。这一套王牌飞行员计划巨大的成绩背后，遵循的就是刻意练习的原则：明确的目标，最优秀的老师，跳出舒适区的训练和及时的反馈改进，以及周而复始的高强度训练。其实整个过程就是一个遵循刻意练习原则的过程。可能你会说，这个刻意练习的方法好是好。可我工作那么忙，哪有整块的时间一直去训练，还要找优秀的导师！太难了。作者说，是这样，不过我们完全可以不停下工作，而是采用边干边学的策略，应用刻意练习的原则。比如，销售技能一直是个隐形知识，很难提升。作者就说有一家叫蓝色兔子的公司，它就是用了刻意训练的原则，在工作中训练销售经理的销售能力的。他们公司每年都会把业绩最好的高级销售经理聚起来开几次会，讨论下一步的销售策略。可是过去的开会往往流于形式，那怎么办呢？公司就想出一个办法，再开会时，让这些高级销售经理一个人模拟公司的真实客户，另一位向他推销公司产品。其他的高级经理在旁边对整个销售过程提供反馈，告诉他这次销售哪里做得好，还有哪些地方可以改变，我有什么经验可以介绍给你。第二天的时候，这个销售经理总结经验，再进行一次销售，然后其他人再进行评估和反馈。公司把这个过程都用视频录下来。这样整个团队的销售技能都得以提高。你看，这个过程，不需要你全职培训，只是把刻意练习的原则融入到日常工作中就能有巨大的成绩。不过你可能说，如果我想提升的能力，既不认识杰出的导师，也没有这样的牛人朋友。那怎么办？作者说：如果没有导师的话，哪怕我们用案例，用优质的书籍也可以实现应用刻意练习的原则提高能力。比如，美国建国早期的伟人本杰明·富兰克林，他早年受的教育水平很有限，能够写出通顺的句子就了不起了，但他又很想提高自己的写作能力，一次偶然的机会看到一本名叫《观察家》的杂志，他发现杂志中的文章质量非常高，特别希望自己也能写出那样漂亮的文章。但是他又不认识这些优秀的作者，给他反馈。那怎么办呢？他就去模仿这个杂志中文章的写作方式，最开始是他去模仿，他们怎样措辞呢？如果我自己写这句话怎么写，我写的方式和他比较，他的好还是我的好，为什么人家的会更好。在用词提升之后，他还是感觉文章哪儿不对，就注意到，原来自己的文章的谋篇布局和结构逻辑也不对，所以他又把观察家杂志上的文章段落打断，自己重新梳理，我写文章会先写什么，后写什么，人家作者为什么有不同的顺序呢？在他不断的揣摩和研究下，富兰克林成为了美国历史上最受尊敬的作家。他的著作《穷查理智慧书》以及后来的自传都成为了美国文学史中的经典案例。你看，富兰克林其实运用了刻意训练原则，解决了一个我们大多数人面临的问题，就是我既想要提高能力，但是又不认识牛人，请不起这样的专业导师，那怎么办？那我们可以运用刻意训练的原则，来拆解高水平的案例和书籍帮助我们提升。你看刚才这个案例中，富兰克林就在没有导师的情况下，通过研究高水平案例，分析他们可能成功的原因，然后自己刻意地，反复训练，不断改进技能。可是还有一种情况，我这个领域连经典的书籍也没有，行业专家的意见也不能确定就是正确，怎么办？作者说，这样的情况，就要回到刻意练习的本质，让自己的行为和结果之间建立及时的、高质量的反馈来提升效能。作者举了一个例子，美国的放射科医生，他们通过X光照片来判断分析乳腺癌病患，随着从业时间变长，他们的判断能力并没有明显进步，有时还会有退步。为什么？原来，放射科医生大约看1000张X光照片里面，可能才有4到8个癌症特征被发现，所以医生获得有效反馈的次数就很少；而且就算这少数情况下，医生觉得X光照片可能有癌症的病变，因为隐私的原因，病例到了自己的私人医生那里，放射科医生也不知道自己的判断是否正确。而且在这个领域，过去也没有特别有效的方法可以提升这种判断X光照片的能力，即使是资历最丰富的专家，也不能确保自己的判断一定都正确。这个时候，如何提升医生的判断能力呢？作者就提出他的解决方案：运用刻意练习的原则，强化决策和结果之间的反馈，然后找差距，刻意训练。具体怎么做呢？作者建议，把过去多年来进行X光照片诊断的病人案例收集起来，再把对应病人后来实际的病例档案找到，从中找到有价值的案例汇总起来，也就是那些有特殊反馈效果的病例照片,比如：当初放射科医生看照片没有发现问题，可后来病人发病了，又或者刚开始医生判断有癌变，可是实际是误诊。这些经过汇总的有价值的案例，就成为训练医生的良好素材，他们可以通过再次诊断这些知道结果的X照片，来研究自己的诊断为什么有问题，如何改进。这样，放射科医生就把过去可能1年才能有一次低效反馈的训练，变成可以每天几十次有效反馈的训练。就这样，应用刻意练习的原则后，放射科医生的诊断正确率有了大幅的提高。这就是一个在没有有效反馈的工作中，运用刻意训练原则提升效能的方法。我们工作中也常常会有这样的情况，你的工作是整个项目流程中的一个环节。比如你是做平面设计的，或者编程开发的技术人员，我们不知道成果怎么样影响结果，我们的工作能力就很难提高，工作几年后会觉得自己在吃老本。刻意训练的原则就告诉我们：我们要想办法把自己的工作和最终结果之间建立起联系。比如，这次做的平面设计，哪些地方客户评价很好，哪些地方客户不满意，是什么原因，可以和自己的同事，相关的部门人员一起讨论改进方案，然后自己再刻意练习，下次继续改进。从而不断提升自己的能力。 总结上面的内容就是刻意练习的主要内容。我们可以看到，要在一个领域快速成长，最好的办法就是让第一流的人，给你指导和反馈，你可以第一时间学习到正确的理念和方法，从而极大地提高学习效率。这就是刻意练习，这也是为什么在少数领域当中，最高水平的老师和方法，加上高强度的训练，就能够创造天才。不过，在不具备这样条件的领域里，我们仍然可以退而求其次，最大程度地利用刻意练习的原理，学习杰出人物的做法，研究他们可能成功的原因，不断尝试改进。最后，我们回顾一下，《刻意练习》这本书中提出了三个观点给我们非常大的启发：第一，天才是可以训练的，我们可以通过高强度的训练，让自己的大脑、身体结构发生变化，从而产生像天赋一般的奇迹能力。第二，为什么大多数人没有训练成天才？是因为我们常常进行的是无效的训练，而只有有目的的训练，那种让我们专注的，及时获得反馈的，不断确定目标而且跳出舒适区的训练，才能够让我们快速地进步。第三，对于天才的训练，只有有目的的训练还不够，还要进一步用刻意练习，找最优秀最杰出的导师去指导自己，然后不断地揣摩别人成功的原因，并且不断地训练和改进，才能获得最大的进步。这本书和此前《成甲说书》讲过的《学习之道》有异曲同工之妙，在《学习之道》当中作者乔希·金提出了划小圈的学习模式，这和刻意练习法则有非常相似的地方，但是刻意练习法则把训练过程讲得更透彻，更具指导性。如果理解了《刻意练习》这本书，再去回过头来听《学习之道》乔希的成功，就能更加深刻地认识到刻意练习和高效学习方法背后的规律。撰稿、讲述：成甲转载至得到APP 如有侵权请和管理员联系删除]]></content>
      <categories>
        <category>book</category>
        <category>刻意练习</category>
      </categories>
  </entry>
</search>
